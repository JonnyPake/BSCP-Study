![[HTTP Host Header Attacks.png]]
# Recon

To test whether a website is vulnerable to attack via the HTTP Host header, you will need an intercepting proxy, such as Burp Proxy and manual testing tools like Repeater and Intruder. 

In short, you need to identify whether you are able to modify the Host header and still reach the target application with your request. If so, you can use this header to probe the app and observe what effect this has on the response.

Burp Suite accurately maintains the separate between the Host header and the target IP address. This separation allows you to supply any arbitrary or malformed Host header that you want, while still making sure that the request is sent to the intended target.
# Basic Password Reset Poisoning

If the app exposes a password reset functionality, determine how the app is generating the password reset URL. It may be possible to inject a malicious domain in that URL by manipulating the Host header or including other headers such as X-Forwarded-Host.

In the labs, use the exploit server's email client to test the functionality and see if the domain is dynamically generated by user controllable input:

- `Host: Exploit-Server.net`
# Web Cache Poisoning via Ambiguous Requests

When probing for potentially Host header attacks, you will often come across seemingly vulnerable behaviour that is not directly exploitable. For example, you may find that the Host header is reflected in the response markup without HTML encoding or even used directly in script imports.

Reflected, client side vulnerabilities, such as XSS, are typically not exploitable when they are caused by the Host header. There is no way for an attacker to force a victim's browser to issue an incorrect host in a useful manner.

Using Burp Suite, add another Host header in the HTTP request with an arbitrary value and identify if the app is using the value in the HTTP responses in an unsafe way. An example:

- `Host: test`
- `Host: normal-host`

Host headers are typically not part of the cache key, so if the app is using a web cache and the malicious payload is cached in the HTTP response, the malicious payload will still reach other user's normal HTTP requests.

As an example, the app may be grabbing the value from the additional Host header and dynamically generating a JavaScript source file. Use the lab's exploit server to host malicious content using the same file path/endpoint. Then, poison the cache with the exploit server's domain using the Host header. Ensure the "Content-Type" header has the correct MIME type.

- `https://user-controllable-domain/resources/file.js`
# Host Header Authentication Bypass

If the /admin endpoint is only available to users on the localhost network, you can try injecting the local host values like so with either of these headers:

- `Host: localhost`
- `X-Forwarded-Host: localhost`

If that does not work, try to encode/obfuscate the header's value or add double Host headers.
# Routing-Based SSRF

The Host headers can be used to perform a SSRF attack. Replace the original Host header value with another domain and determine if the app initiates a request to the domain. Burp Collaborator can be used here for testing. 

If this works, then it means the app is vulnerable to SSRF through the Host header.

This can be used to access the /admin panel of the app, as the SSRF payload will target an internal IP address. Use Intruder to brute force if needed. An example:

- `GET /admin HTTP/2`
- `Host: 192.168.0.2`
# SSRF via Flawed Request Parsing

The Host headers can be used to perform a SSRF attack. Replace the original Host header value with another domain and determine if the app initiates a request to the domain. Burp Collaborator can be used here for testing.

If this does not work, then use an additional Host header or the X-Forwarded-Host header, for example.

Another technique to try is to supply an absolute URL in the request line:

- `GET https://vulnerable-website.com/admin HTTP/2`
- `Host: bad-stuff-here - 192.168.0.1`

If this works, then it means the app is vulnerable to SSRF through the Host header, while injecting the absolute URL of the application in the request line.
# Host Validation Bypass via Connection State Attack

Poorly implemented HTTP servers sometimes work on the dangerous assumption that certain properties, such as the Host header, are identical for all HTTP/1.1 requests sent over the same connection. 

For example, you may occasionally encounter servers that only perform thorough validation on the first request they receive over a new connection. In this case, you can potentially bypass this validation by sending an innocent-looking initial request then following up with the malicious one down the same connection.

To attack the app using the connection state attack::

- Use Repeater to place 2 different tabs into a new group and change the send mode to "Send group in sequence (single connection)".
- Ensure the first tab contains the normal HTTP request. The second tab can contain the malicious HTTP request. Same technique as previous examples, can be used here.

